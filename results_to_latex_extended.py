import re
import math

regexp = re.compile(
    r"Critical Token Ratio: (\d+.\d+)(?:[^N]|\n)+"
    + r"FINAL RESULTS FOR (.*)(?:[^F]|\n)+ACCEPT: (\d+)(?:[^F]|\n)+REFUSE: (\d+)(?:[^T]|\n)+NONSENSE: (\d+)(?:[^T]|\n)+ERROR: (\d+)(?:[^F]|\n)+REFUSE:\n"
    + r".*L2 norm: (\d+.\d+).*Std: (\d+.\d+).*\n" * 3
)

data = "".join([open(f"All_{name}_results.txt").read() for name in ["phi3", "qwen"]])

phi3, qwen = [], []
for name, out in [("Phi", phi3), ("Qwen", qwen)]:
    data = open(f"All Results for {name} (updated).txt").read()
    data = regexp.findall(data)
    min_asr = 100.0
    for i, (ctr, model, accept, refuse, nonsense, error, l2e, stde, l2m, stdm, l2l, stdl) in enumerate(data):
        assert model.startswith(name.lower())
        if i < 3:
            layers, reg = "none", 0
        else:
            _, layers, _, reg = model.split("-", 3)
        accept, refuse, nonsense, error = int(accept), int(refuse), int(nonsense), int(error)
        l2e, stde, l2m, stdm, l2l, stdl = float(l2e), float(stde), float(l2m), float(stdm), float(l2l), float(stdl)
        ctr = float(ctr)
        assert error == 0
        assert accept + refuse + nonsense + error == 200
        asr = accept / (accept + refuse + nonsense + error) * 100
        min_asr = min(min_asr, asr)
        out.append([float(reg), layers, asr, (l2e, stde, l2m, stdm, l2l, stdl), ctr])
    for item in out:
        item.append(item[-3] == min_asr)

assert len(qwen) == 21
assert len(phi3) == 21

def format_ASR(asr: float, is_min_asr: bool):
    res = f"{asr:.1f}"
    if is_min_asr:
        res = r"\textbf{" + res + r"}"
    return res

def format_L2(l2_std):
    l2e, _, l2m, _, l2l, _ = l2_std
    return f"{int(l2e)}/{int(l2m)}/{int(l2l)}"

def format_Std(l2_std):
    def format_float(v):
        # num, exp = f"{v:.1e}".split("e-0")
        # return f"{num}e-{exp}"
        assert v >= 1e-4
        return f"{int(v*1e4)}"
    _, stde, _, stdm, _, stdl = l2_std
    return f"{format_float(stde)}/{format_float(stdm)}/{format_float(stdl)}"

def format_ctr(ctr):
    return f"{ctr:.2f}"

print(r"""% THIS TABLE IS AUTOGENERATED WITH results_to_latex.py IN THE REPO
\begin{table*}[t]
\centering
\begin{tabular}{|c c|c c|c c|c c|c c|}
\hline
\multicolumn{2}{|c|}{\multirow{2}{*}{\textbf{Regularization}}} & \multicolumn{2}{c|}{\multirow{2}{*}{\textbf{GCG ASR (\%)}}} & \multicolumn{2}{c|}{\textbf{REFUSE Grad L2}} & \multicolumn{2}{c|}{\textbf{REFUSE Grad Std}} & \multicolumn{2}{|c|}{\multirow{2}{*}{\textbf{CTR}}}\\
& & & & \multicolumn{2}{c|}{(E/M/L)} & \multicolumn{2}{c|}{(E/M/L, $\cdot 10^{-4}$)} & &\\
$\lambda$ & $I$ & \textbf{Qwen} & \textbf{Phi} & \textbf{Qwen} & \textbf{Phi} & \textbf{Qwen} & \textbf{Phi} & \textbf{Qwen} & \textbf{Phi} \\""")
for i, ((q_reg, q_layers, q_asr, q_l2_std, q_ctr, q_is_min_asr), (p_reg, p_layers, p_asr, p_l2_std, p_ctr, p_is_min_asr)) in enumerate(zip(qwen, phi3)):
    assert q_reg == p_reg
    assert p_layers == q_layers
    if i == 0:
        print(r"""\hline \multicolumn{2}{|c|}{original model} """, end="")
    elif i == 1:
        print(r"""\multicolumn{2}{|c|}{no reg (const LR)} """, end="")
    elif i == 2:
        print(r"""\multicolumn{2}{|c|}{no reg (decay LR)} """, end="")
    else:
        if i % 3 == 0:
            print(rf"""\hline \multirow{{3}}{{*}}{{$10^{{{int(math.log10(q_reg))}}}$}}""", end="")
        print(rf"""& {q_layers} """, end="")
    print(rf"""& {format_ASR(q_asr, q_is_min_asr)} & {format_ASR(p_asr, p_is_min_asr)} & {format_L2(q_l2_std)} & {format_L2(p_l2_std)} & {format_Std(q_l2_std)} & {format_Std(p_l2_std)} & {format_ctr(q_ctr)} & {format_ctr(p_ctr)}\\""")
print(r"""\hline
\end{tabular}
\caption{ASR, REFUSE Gradient L2 Norms and Standard Deviations (Early/Middle/Late layers)}
\label{tab:refuse_complete}
\end{table*}""")
